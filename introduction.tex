\section{Introduction}
\label{sec:intro}

In recent years, the demand for hardware with smaller form factor and higher transistor density has been steadily increasing. Consequently, it has become difficult to create high quality hardware by hand-crafting RTL designs. A behavioral synthesis tool takes a behavioral
%n implementation independent 
design description (in C, C++, or SystemC), often referred to as Electronic System Level (ESL) design, and automatically generates an optimized RTL design (in hardware
description languages such as VHDL or Verilog). Industrial users
have found that behavioral design reduces the design effort
by 50\% or more while attaining excellent performance results~\cite{Moussa99}. However, the adoption of this approach is
contingent upon certifying that the RTL design indeed
corresponds to the ESL description.

Loop pipelining is one of the most complex transformations in behavioral synthesis. It is available in most commercial synthesis tools ({\em e.g.}, AutoESL~\cite{autoesl} and Cynthesizer~\cite{forte}) and is
crucial to producing hardware with high throughput and low latency by allowing temporal overlap of successive loop
iterations. Certifying the correspondence between a sequential design and its pipelined counterpart is challenging due to the huge semantic gap between the two
designs.

We develop a framework for designing certifiable
pipelining algorithms. It has three pipelining primitives on which one can build a pipelining algorithm. In particular, using our framework, we develop a certifiable
loop pipelining algorithm that can be used for certifying a pipeline generated by a behavioral synthesis tool. Our algorithm takes a sequential design as input,
together with certain parameters readily available from a behavioral synthesis tool and produces a pipeline reference
model. It has been shown that such a reference model can be verified with the pipelined RTL using sequential equivalence checking (SEC)~\cite{hrx:dac-12}.

%We develop a framework to create certifiable pipeline generation algorithms. We identify three pipelining primitives which have the potential to affect the correctness of a design while pipelining. We show how to create a simple loop pipeline generation algorithm using our framework. The algorithm takes sequential design and pipeline interval (obtained from the behavioral synthesis tool) as input and produces a pipeline reference model. 

%The reference model can then be verified with the pipelined RTL using Sequential Equivalence Checking~\cite{hrx:dac-12}. It is possible because the reference model is created using feedback from the synthesis tool, so it is structurally similar to the pipelined RTL. An algorithm was proposed in an earlier paper ~\cite{hrx:dac-12} to create the pipeline reference model and was tested on a behavioral synthesis tool, AutoESL. However, the proposed algorithm was not certified.

\medskip
The key contributions of this paper are:
\begin{enumerate}
\item a framework of three pipelining primitives to create certifiable pipelining algorithms;
\item a simple certifiable loop pipelining algorithm using our framework; and 
\item a proof methodology for mechanically certifying such an algorithm using a theorem prover.
\end{enumerate}

%Note that we choose not to certify the algorithm proposed by Hao et al.~\cite{hrx:dac-12} because we believe it would be a messy and difficult proof. Also, one of our key insights is that while the certification framework requires an algorithm that generates pipeline reference model that can be used for SEC with RTL produced by synthesis tools, we are free to choose an implementation of the transformation amenable to formal reasoning. 

The rest of the paper is organized as
follows. Section~\ref{sec:background} provides relevant background and an uncertified algorithm to generate
pipelines. Section~\ref{sec:not-verifiable} explains our motivation behind developing the framework. Section~\ref{sec:fundamental-tasks} explains the primitives for creating certifiable
pipelining algorithms in behavioral
synthesis. Section~\ref{sec:pipeline-algo} presents a simple certifiable pipelining algorithm using these primitives. Section~\ref{sec:proof}
explains our approach to certify the primitives. Section~\ref{sec:related} explains related work and Section~\ref{sec:concl} concludes this paper and discusses future work.

%Verifying a complex pipelined design by standard sequential equivalence checking (SEC) does not work. Equivalence checking requires mapping of internal operations and variables in the two design per clock cycle. Loop pipelining produces a new schedule and a different control flow as compared to sequential design as more than one iterations are being done in parallel in a single clock cycle. To avoid data hazards (overwrite of variables before being read), new variables are introduced in the pipelining process. Due to all this, mapping of internal operations between sequential and pipelined design is lost making SEC infeasible. Since, tool vendors do not disclose their implementation of pipelining transformation, certification by theorem proving is also ruled out.

