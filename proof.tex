\section{Mechanized Proof Using Theorem Prover}
\label{sec:proof}

Correctness of loop pipelining algorithm using our framework naturally breaks
down into correctness of $\phi$-elimination, shadow register and interchange primitives. For each of these three primitives, mechanical certification has two aspects:

\begin{enumerate}
\item {\bf Correctness of primitive:} We must prove that
  applying a particular primitive is correct, {\em i.e.},
  maintains a certain invariant.  This is proven without
  considering how it is applied in the context of a pipeline
  synthesis algorithm.  For example, for the interchange
  primitive, we prove that starting with the same state $s$,
  executing two microsteps in sequence produces the same
  state as executing the same microsteps in interchanged
  order.  Note that this is independent of how the primitive
  is actually applied during pipelining.
 
\item {\bf Correctness of primitive application :} This
  step is to show that the primitive is applied by our
  algorithm properly, {\em i.e.}, the environment
  assumptions where the {\bf Correctness of primitive}
  depends are maintained appropriately by the algorithm at
  the point where the primitive is applied.  

%% How to set up the Inductive proof
%%   to ensure correctness of CCDFG after applying a primitive:
%%   We prove that execution of the entire CCDFG is not changed
%%   when the primitive is applied. Also, we need to statically
%%   ensure that the function we have created to apply the
%%   primitive is correct.
\end{enumerate}

\medskip
\noindent {\bf Correctness of primitive:} We give an outline of the proof to justify that the three primitives are correct.

\begin{enumerate}
\item {\bf $\phi$-elimination primitive:} We prove that execution
  of a $\phi$-construct is same as executing corresponding
  assignment statements. Note that this is not trivial since
  given a microstep in a scheduling step containing the
  $\phi$-construct, the algorithm has to use static analysis
  to deduce the previous scheduling step.

\item {\bf Shadow register primitive:} We prove that adding
  a shadow register microstep $x\_reg = x$ does not change the
  value of any variable except the shadow variable. Also, we
  prove that now since value of $x\_reg$ would be equal to value
  of $x$, executing a statement which reads $x$ has same
  effect on the state as executing a statement which reads
  $x\_reg$ till the next write of $x$. As mentioned earlier, we
  determine the variables read and written in a statement by
  analyzing the execution semantics.

\item {\bf Interchange primitive:} We want to prove that we can interchange two microsteps which do not have
  read-write conflict. Given an initial state, the state after
  executing microsteps $m$ and $n$ is the same as the state after
  executing $n$ then $m$ if $m$ and $n$ have no read-write
  conflict. Suppose, state after
  executing $m$ and $n$ is $s_1$ and after executing $n$ and
  $m$ is $s_2$. We prove that for any variable $x$, its
  value remains same in $s_1$ and $s_2$.  After normalizing
  the states, we can prove that $s_1$ is equal to $s_2$ i.e,
  states remain same after executing the two microsteps in
  sequence or in an interchanged order. Again, reasoning about read and
  write of statements involves reasoning about execution
  semantics of all types of microsteps present in the
  language which is not trivial.
\end {enumerate}

\medskip
\noindent {\bf Correctness of primitive application:} The
correctness of each primitive discussed above, entails a
so-called ``assume-guarantee'' reasoning: the prmitive is
guaranteed to maintain the desired invariant if and only if
it is applied under certain well-formed conditions.  To use
these correctness statements to verify the algorithm, we
must therefore prove that the algorithm applies each
primitive appropriately, maintaining the well-formedness
condition required for the correctness of the primitive.

Note that verifying this requires an inductive proof
relating the states of the CCDFG $C'$ generated after the
application of the transformation with the original CCDFG
$C$.  The induction is on the lengths of execution of $C$
and $C'$.  Note that the induction is non-trivial because
transformations have significant ``global'' effect on a
CCDFG.  These include one or more of the following:

\begin{enumerate}
\item replacing one microstep of $C$ with more than one
  microsteps in $C'$ ({\em e.g.}, $\phi$-elimination), or
\item interchanging several microsteps ({\em e.g.},
  interchange), or
\item changing the variable being read or written in several
  microsteps ({\em e.g.}, shadow register)
\end{enumerate}
The upshot is that an inductive theorem relating $C$ and
$C'$ must be strong enough to comprehend the global effects.
For instance, an inductive statement showing the
correctness of $\phi$-elimination must account for the fact
that the number of microsteps of $C$ is different from that
of $C'$.  Thus an execution of $C$ for $n$ microsteps must
correspond to an execution of $C'$ for a different number
$m$ of microsteps, where the number $m$ is a function of $n$
and the structures of $C$ and $C'$; the statement of the
correctness of $\phi$-elimination must characterize the
value of $m$ precisely, perhaps defining functions that
statically and symbolically execute $C$ and $C'$, in order
to be provable by induction.  Furthermore the functions so
introduced for static symbolic execution must themselves be
proven correct.

%% \begin{enumerate}
%% \item Phi Elimination: Note that a $\phi$-construct
%%   decomposes into one or more assignment statements. So, the
%%   number of total microsteps in $C_2$ is more than or equal
%%   to microsteps in $C_1$.  

%% Inductive hypothesis: Executing n microsteps of $C_1$ is equal to executing some corresponding f(n) microsteps of $C_2$. f(n) can be derived from n by statically analyzing number of $\phi$-statements in $C_1$.

%% Induction base case: Executing $0$ microsteps of $C_1$ is equal to executing $f(0) = 0$ microsteps of $C_2$. This is trivially true as both start from the same state $s$.
 
%% Inductive step: Prove that executing $n + 1$ microsteps of $C_1$ is equal to executing $f(n + 1)$ microsteps of $C_2$. We can prove that executing $n + 1$ microsteps is equal to executing $n$ microsteps and then executing $(n + 1)th$ step. So, this proof can be split into two cases.
  
%% \begin{itemize}
%% \item Case I: The microstep at $(n + 1)$ level is not a $\phi$-construct. Then, we need to prove that microstep at $(n + 1)$ level in $C_1$ is same as microstep at $f(n + 1)$ level in $C_2$ and their execution produces same result.
%% %$$ f(n + 1) = f(n) + 1 $$.

%% \item Case II: The microstep at $(n + 1)$ level is a $\phi$-construct. Then, we need to prove that there are corresponding assignment statements between $f(n)$ and $f(n + 1)$ level. Then, we use the proof of the phi elimination primitive discussed earlier that execution of $\phi$-construct is same as execution of corresponding assignment statements.
%% \end{itemize}

%% \item Shadow Register --- Let $m$ be the microstep in $C_1$ which writes the variable $v$ which may be overwritten while pipelining. So, the primitive adds a shadow register step after $m$ in $C_2$, say $$ vr = v$$ where $vr$ is a shadow variable. Let the last step that reads $v$ be $l$. Suppose total number of microsteps in $C_1$ is $k$, then $C_2$ has $k + 1$ microsteps because shadow register primitive adds one step (shadow register step).

%% $$ k = a + (k - a - b)+ b $$
%% where $a$ is the number of microsteps upto and including microstep $m$ and $b$ is the number of microsteps after microstep $l$.

%% \begin{itemize}
%% \item Case I: Executing $n$ microsteps in $C_1$ is equal to executing $n$ microsteps in $C_2$ where $n \leq a$.

%% Base Case: $n = 0$. This is trivially true as both start from the same state $s$.

%% Inductive hypothesis: Executing $n - 1$ microsteps in $C_1$ is equal to executing $n - 1$ microsteps in $C_2$ where $n <= a$.

%% Induction Step: Prove that executing $n$ microsteps of $C_1$ is equal to executing $n$ microsteps of $C_2$. We can prove that executing $n $ microsteps is equal to executing $n - 1$ microsteps and then executing step at $n$ level. So, for this proof, we need to prove that the step at level $n$ for any $n \leq a$ is same in both $C_1$ and $C_2$.

%% \item Case II: Executing $n$ microsteps in $C_1$ is equal to executing $n + 1$ microsteps in $C_2$ where $ a < n <= b $.

%% We know, step at level $(a + 1)$ in $C_2$ is a shadow register step which does not change the state with respect to real variables. After that, we have two cases:

%% Case I: The step at level $n$ of $C_1$ is equal to the step at level $(n + 1)$ of $C_2$.

%% Case II: Shadow register primitive replaces read of variable $v$ in the step at level $n$ of $C_1$ with $vr$ in the $(n + 1)$ step of $C_2$ which does not affect execution.

%% \item Case III: Executing $n$ microsteps in $C_1$ is equal to executing $n + 1$ microsteps in $C_2$ where $n \geq b$.

%% Base Case: $n = b$. This is proved by Case II.

%% Inductive hypothesis: Executing $n - 1$ microsteps in $C_1$ is equal to executing $n$ microsteps in $C_2$ where $n > b$.

%% Induction Step: Prove that executing $n$ microsteps of $C_1$ is equal to executing $n + 1$ microsteps of $C_2$. We know that executing $n $ microsteps is equal to executing $n - 1$ microsteps and then executing the step at level $n$. So, we need to prove that
%% the step at level $n$ in $C_1$ is equal to the step at level $(n+1)$ in $C_2$ for n > b. 
%% \end{itemize}

%% \item Interchange: Let $m$ and $n$ be the two microsteps in $C_1$ which are adjacent and have no read-write conflict. Suppose total number of microsteps in $C_1$ is $k$, then $C_2$ also has $k$ microsteps because interchange primitive does not add or remove any microsteps.
%% $$ k = i + 2 + (k - i - 2) $$
%% where $i$ is the number of microsteps before microstep $m$ and $k - i - 2$ is the number of microsteps after microstep $n$.

%% \begin{itemize}
%% \item Case I: Executing $n$ microsteps in $C_1$ is equal to executing $n$ microsteps in $C_2$ where $n \leq i$.

%% Base Case: $n = 0$. This is trivially true as both start from the same state $s$.

%% Inductive hypothesis: Executing $n - 1$ microsteps in $C_1$ is equal to executing $n - 1$ microsteps in $C_2$ where $n \leq i$.

%% Induction Step: Prove that executing $n $ microsteps of $C_1$ is equal to executing $n $ microsteps of $C_2$. We know that executing $n $ microsteps is equal to executing $n - 1$ microsteps and then executing the step at level $n$. So, to prove that states after executing $n$ microsteps are equal, we need to prove that for any $n \leq i$, the step at level $n$ both $C_1$ and $C_2$ are same.

%% \item Case II: Executing $i + 2$ microsteps in $C_1$ is equal to executing $i + 2$ microsteps in $C_2$.

%% We know, $m$ is the microstep at level $(i + 1)$ in $C_1$ and $n$ is the microstep at $(i + 2)$ level. We also know that executing $ i + 2 $ microsteps is equal to first executing $i $ microsteps and then executing $2$ microsteps after that. Since, Case I proves that executing $i$ microsteps is equal in $C_1$ and $C_2$, we are left with one case:
%% To prove that the two microsteps after $i$ level in $C_2$ are $n$ and $m$. This can be proved as we have proved earlier that executing $m$ followed by $n$ is same as executing $n$ followed by $m$ if there are no-read write conflicts between $n$ and $m$
%% (proof of interchange primitive).

%% \item Case III: Executing $n$ microsteps in $C_1$ is equal to executing $n$ microsteps in $C_2$ where $n \geq i + 2$.

%% Base Case: $n = i + 2$. This is proved by Case II.

%% Inductive hypothesis: Executing $n - 1$ microsteps in $C_1$ is equal to executing $n - 1$ microsteps in $C_2$ where $n > i + 2$.

%% Induction Step: Prove that executing $n $ microsteps of $C_1$ is equal to executing $n $ microsteps of $C_2$. We know that executing $n $ micro is equal to executing $n - 1$ microsteps and then executing the step at level $n$. So, to prove that states after executing $n$ microsteps are equal, we need to prove that for any $n > i + 2$, the step at level $n$ in both $C_1$ and $C_2$ is same.

%% <<<<<<< .mine
%% %% \end{itemize}
%% %% \end{enumerate}
%% %% \medskip
%% %% \bf{Proof progress}
%% %% %\label{subsec:proof-progress}
%% =======
%% \end{itemize}
%% \end{enumerate}
%% \medskip
%% \em {\bf {Proof progress}}
%% %\label{subsec:proof-progress}
%% >>>>>>> .r36

At the time of this writing, we have (1)~developed a
framework to create certifiable pipelining algorithms (2)~created a
certifiable algorithm to generate a pipeline reference model
using feedback from the tool and our three design primitives
(3)~completed the proof for correctness of the three
primitives. (4)~substantially completed the inductive proof
of correctness of application for $\phi$-elimination and
interchange primitives using ACL2 theorem prover~\cite{car}.
 
We expect the proofs of other induction operations to be
similar since their definition involves similar static analysis. Our formalization involves
$186$ definitions. About $350$ mechanically checked
lemmas are involved in the proofs that have been completed.
